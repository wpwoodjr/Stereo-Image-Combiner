==========  new code ===========

Try leaving transparent background on

98 or 99%

try determining one line significantly diff to another

setCropState in CropManager not decide if crop is needed

crop borders on single images too?

Sometimes borders/transparent checkboxes in conflict

Set gap/border based on import single image?

Why does it find additional border when reload? Maybe only when saved with a border?

Arches a mode, initial crop not maintained - ok now?
  but now image alignment is lost because full image not displayed
  but what about aspect ratio
  OK so cross vs parallel arches - alignment

======== old code ===========

Mac cropbox drawing all screwed up

Check drawImage in alignMode works with Safari

========== Maybe later ==========
thin line at 0% gap (but not in saved image)

Use currentparams for imgages[0].width etc
need currentScale?

Can remove yOffset?

only look at some mouse movements to decrease CPU?

move other box in side by side mode, like in align mode?

lines on shadow, maybe due to off by one issue?  timing?

want slow movement on resize handles?

duplicate tab in a mode or after a crop, display scale is from a mode or cropped scale, eg 72 instead of 100

iOS may need to call onResize after a timeout, as documented in MB:
    // ios is not always reporting correct width and height on orientation change
    // use timeout to redo the resize after things have hopefully settled down

*Align Mode*
need better indicators of what will move in align mode, esp arrow mode
  for instance the transparency isn't a clear indicator
  in arrow mode you have no idea

check fs and align mode

applyCrop probably doesn't have to call alignModeRestorePreviousScalePercent, except that when re-cropping, startCrop calls
  enterAlignMode, the previous scale is remembered incorrectly as the previous alignMode scale, so switching to side-by-side mode is using the alignMode scale
  
On the first crop, enterAlignMode captures the previous scale as the uncropped scale; so when switching to side by side mode, this is actually
  perchance OK because side by side mode also uses the uncropped scale.


========== Hard to fix and maybe not worth it (or both) ==========

Crop, since gap gets smaller on geese, scale size is too small, not optimal, can't even get it bigger with resize

Gap should only be in area between crop boxes

scroll bar beside image moves header to left in Chrome

reducing 1 from full display scale moves right filename and fullscreen icon to the left

May want to revert scale after fullscreen mode

Add 1/3 crop lines in align mode

cursor disappears after handling a keypress


        // --- Stage 2: Split the Stage 1 cropped area and Refine Inner Horizontal Edges to find the Gap ---
        const nominalSplitPointAbsolute = outerX1 + Math.floor(stage1ContentWidth / 2);

        let finalLeftImageRightX = outerX1 - 1;
        let gapFound = false;
        for (let currentX = nominalSplitPointAbsolute - 1 + this.MIN_IMAGE_DIMENSION; currentX >= outerX1; currentX--) {
        // let gapFound = true;
        // for (let currentX = nominalSplitPointAbsolute - 1; currentX >= outerX1; currentX--) {
            if (this._getColumnConsistency(imageData, currentX, 0, imgHeight - 1, imgWidth, imgHeight).percent < this.CONSISTENCY_THRESHOLD) {
                if (gapFound) {
                    finalLeftImageRightX = currentX; 
                    break;
                } else if (currentX < nominalSplitPointAbsolute - 1 - this.MIN_IMAGE_DIMENSION) {
                    finalLeftImageRightX = nominalSplitPointAbsolute - 1;
                    break;
                }
            } else {
                gapFound = true;
            }
        }

        let finalRightImageLeftX = outerX2 + 1;
        for (let currentX = nominalSplitPointAbsolute; currentX <= outerX2; currentX++) {
            if (this._getColumnConsistency(imageData, currentX, 0, imgHeight - 1, imgWidth, imgHeight).percent < this.CONSISTENCY_THRESHOLD) {
                finalRightImageLeftX = currentX; 
                break;
            }
        }

        const img1ProposedWidth = finalLeftImageRightX - outerX1 + 1;
        const img2ProposedWidth = outerX2 - finalRightImageLeftX + 1;
        const gapSize = finalRightImageLeftX - finalLeftImageRightX - 1;
        console.log(`Stage 2 (find gap):
    Found gap at: ${finalLeftImageRightX + 1}, size: ${gapSize},
    Img1(x:${outerX1}, w:${img1ProposedWidth}),
    Img2(x:${finalRightImageLeftX}, w:${img2ProposedWidth})`);

        if (finalRightImageLeftX <= finalLeftImageRightX || 
            img1ProposedWidth < this.MIN_IMAGE_DIMENSION ||
            img2ProposedWidth < this.MIN_IMAGE_DIMENSION) {
            console.warn("Stage 2: Gap refinement invalid. Splitting original image in half.");
            return this.splitAreaInHalfVertically(0, 0, imgWidth, imgHeight);
        }

