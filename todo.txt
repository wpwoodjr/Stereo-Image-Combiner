==========  new code ===========
Goose H/V:
  No crop needed not ok when h1 != h2 and using min crop
    Move crop region creation into analyse phase
    Check X and Y not just Y

Contraction OK on single image?
    No... on Goose vertical / goose square with black background, it sees a gap of 1 and right border of 1
    This is because the initial outerX2 and innerX2 scans are scanning the whole image, not just where the Goose is

Try leaving transparent background on

why no handles on right in DEBUG mode?

Why does it find additional border when reload? Maybe only when saved with a border?

Arches a mode, initial crop not maintained - ok now?
  but now image alignment is lost because full image not displayed
  but what about aspect ratio
  OK so cross vs parallel arches - alignment

========== Maybe later ==========
Have button to select type of cropping: min, max, none

Have fn to crop borders on two images instead of having to recombine them first

Use currentparams for imgages[0].width etc
need currentScale?

Can remove yOffset?

only look at some mouse movements to decrease CPU?

move other box in side by side mode, like in align mode?

lines on shadow, maybe due to off by one issue?  timing?

want slow movement on resize handles?

duplicate tab in a mode or after a crop, display scale is from a mode or cropped scale, eg 72 instead of 100

iOS may need to call onResize after a timeout, as documented in MB:
    // ios is not always reporting correct width and height on orientation change
    // use timeout to redo the resize after things have hopefully settled down

*Align Mode*
need better indicators of what will move in align mode, esp arrow mode
  for instance the transparency isn't a clear indicator
  in arrow mode you have no idea

check fs and align mode

applyCrop probably doesn't have to call alignModeRestorePreviousScalePercent, except that when re-cropping, startCrop calls
  enterAlignMode, the previous scale is remembered incorrectly as the previous alignMode scale, so switching to side-by-side mode is using the alignMode scale
  
On the first crop, enterAlignMode captures the previous scale as the uncropped scale; so when switching to side by side mode, this is actually
  perchance OK because side by side mode also uses the uncropped scale.


========== Hard to fix and maybe not worth it (or both) ==========
drag and drop doesn't work in firefox
  set about:config setting: dom.events.dataTransfer.imageAsFile.enabled to true
  then will work ff to ff but not chrome to ff

thin line at 0% gap (but not in saved image)

Crop, since gap gets smaller on geese, scale size is too small, not optimal, can't even get it bigger with resize

Gap should only be in area between crop boxes

scroll bar beside image moves header to left in Chrome

May want to revert scale after fullscreen mode

Add 1/3 crop lines in align mode

cursor disappears after handling a keypress


        // --- Stage 2: Split the Stage 1 cropped area and Refine Inner Horizontal Edges to find the Gap ---
        const nominalSplitPointAbsolute = outerX1 + Math.floor(stage1ContentWidth / 2);

        let finalLeftImageRightX = outerX1 - 1;
        let gapFound = false;
        for (let currentX = nominalSplitPointAbsolute - 1 + this.MIN_IMAGE_DIMENSION; currentX >= outerX1; currentX--) {
        // let gapFound = true;
        // for (let currentX = nominalSplitPointAbsolute - 1; currentX >= outerX1; currentX--) {
            if (this._getColumnConsistency(imageData, currentX, 0, imgHeight - 1, imgWidth, imgHeight).percent < this.CONSISTENCY_THRESHOLD) {
                if (gapFound) {
                    finalLeftImageRightX = currentX; 
                    break;
                } else if (currentX < nominalSplitPointAbsolute - 1 - this.MIN_IMAGE_DIMENSION) {
                    finalLeftImageRightX = nominalSplitPointAbsolute - 1;
                    break;
                }
            } else {
                gapFound = true;
            }
        }

        let finalRightImageLeftX = outerX2 + 1;
        for (let currentX = nominalSplitPointAbsolute; currentX <= outerX2; currentX++) {
            if (this._getColumnConsistency(imageData, currentX, 0, imgHeight - 1, imgWidth, imgHeight).percent < this.CONSISTENCY_THRESHOLD) {
                finalRightImageLeftX = currentX; 
                break;
            }
        }

        const img1ProposedWidth = finalLeftImageRightX - outerX1 + 1;
        const img2ProposedWidth = outerX2 - finalRightImageLeftX + 1;
        const gapSize = finalRightImageLeftX - finalLeftImageRightX - 1;
        console.log(`Stage 2 (find gap):
    Found gap at: ${finalLeftImageRightX + 1}, size: ${gapSize},
    Img1(x:${outerX1}, w:${img1ProposedWidth}),
    Img2(x:${finalRightImageLeftX}, w:${img2ProposedWidth})`);

        if (finalRightImageLeftX <= finalLeftImageRightX || 
            img1ProposedWidth < this.MIN_IMAGE_DIMENSION ||
            img2ProposedWidth < this.MIN_IMAGE_DIMENSION) {
            console.warn("Stage 2: Gap refinement invalid. Splitting original image in half.");
            return this.splitAreaInHalfVertically(0, 0, imgWidth, imgHeight);
        }

